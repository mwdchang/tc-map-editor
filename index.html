<!DOCTYPE html>
<html>
<head>
  <link href="styles.css" rel="stylesheet" type="text/css">
  <script src="vendor/lodash.js"></script>
  <script src="vendor/d3.min.js"></script>
  <script src="vendor/d3-selection-multi.min.js"></script>
  <script src="util.js"></script>

  <title>Turncraft || Map Editor 0.1</title>
</head>
<body>
  <h4>Turncraft Map Editor - Version 0.1</h4>
  <div class="container">
    <div>
       <svg id="map" width="450px" height="450px" viewBox="0 0 200 200"></svg>
    </div>
    <div style="margin-left: 2rem" id="controls">

      <div class="row">
        <span class="tbtn" onClick="clearData()">Clear</span>
        <span class="tbtn">Export</span>
        <span class="tbtn" onClick="importPopup()">Import</span>
      </div>
      <hr><br>

      <!-- brush -->
      <div class="row">
        <span class="label">Brush</span>
        <span class="tbtn brushBtn active">1x1</span>
        <span class="tbtn brushBtn">3x3</span>
        <span class="tbtn brushBtn">5x5</span>
      </div>
      <hr><br>
    </div>
  </div>

  <div class="overlay">
    <div class="popup">
      <div>Import - Paste stuff below</div>
      <textarea style="width:90%; height:80%"></textarea>
      <span class="tbtn">Import</span>
    </div>
  </div>
</body>
<script>

let scale = d3.scaleOrdinal().range(d3.schemeCategory10);

let brush = 0;
let actionFn = null;

function createRow(target, rowData) {
  let row = target.append('div').classed('row', true);
  row.append('span').classed('label', true).html(rowData.label);
  row.selectAll('.actionBtn')
    .data(rowData.actions).enter()
    .append('span')
    .classed('tbtn', true)
    .classed(rowData.class, true)
    .html(d=>d.label);
}


let heightRow = {
  label: 'Height',
  class: 'actionBtn',
  actions: [
    {label: 'Raise', action:(d)=>d.h++},
    {label: 'Lower', action:(d)=>d.h--}
  ]
};

let terrainRow = {
  label: 'Terrain',
  class: 'actionBtn',
  actions: [
    {label: '0', action:(d)=>d.t=0},
    {label: '1', action:(d)=>d.t=1},
    {label: '2', action:(d)=>d.t=2},
    {label: '3', action:(d)=>d.t=3},
    {label: '4', action:(d)=>d.t=4},
  ]
};

let resourceRow = {
  label: 'Resource',
  class: 'actionBtn',
  actions: [
    {label: 'A'},
    {label: 'B'}
  ]
};


let target = d3.select('#controls');
createRow(target, heightRow);
createRow(target, terrainRow);
createRow(target, resourceRow);
target.append('div').classed('row', true)
  .attr('id', 'summary').style('font-size', '80%');


d3.selectAll('.brushBtn').on('click', function(d, i) {
  d3.selectAll('.brushBtn').classed('active', false);
  d3.select(this).classed('active', true);
  brush = i;
});

d3.selectAll('.actionBtn').on('click', function(d, i) {
  d3.selectAll('.actionBtn').classed('active', false);
  d3.select(this).classed('active', true);
  actionFn = d.action;
});


let GRID_SIZE = 32;
let w = 200 / GRID_SIZE;
let h = 200 / GRID_SIZE;
let canvas = d3.select('#map').append('g');


let data = [];
for (let i=0; i < GRID_SIZE; i++) {
  data.push([]);
  for (let j=0; j < GRID_SIZE; j++) {
    data[i].push({
      x: i, y: j, h: 0, t: 0
    })
  }
}


for (let x=0; x < GRID_SIZE; x++) {
  for (let y=0; y < GRID_SIZE; y++) {
    canvas.append('rect')
      .classed('cell', true)
      .attr('x', x*w)
      .attr('y', y*w)
      .attr('width', w)
      .attr('height', h)
      .datum(data[x][y])
      .style('fill', '#FFF')
      .style('stroke', 'none');
  }
}

XGrid(canvas, GRID_SIZE, h);
YGrid(canvas, GRID_SIZE, w);



function apply(x, y) {
  let xmin = Math.max(x - brush, 0);
  let ymin = Math.max(y - brush, 0);
  let xmax = Math.min(x + brush, GRID_SIZE-1);
  let ymax = Math.min(y + brush, GRID_SIZE-1);

  for (let i=xmin; i <= xmax; i++) {
    for (let j=ymin; j <= ymax; j++) {
      actionFn(data[i][j]);
    }
  }
}


function update() {

  canvas.selectAll('.cell')
    .style('fill', function(d) {
      return d3.rgb(255-20*d.h, 255-20*d.h, 255-20*d.h);
    });

  canvas.selectAll('.terrain').remove();

  let terrain = _.flatten(data).filter( d => d.t > 0)
  canvas.selectAll('.terrain')
    .data(terrain)
    .enter()
    .append('rect')
    .classed('terrain', true)
    .attr('x', d=>d.x*w+1)
    .attr('y', d=>d.y*h+1)
    .attr('width', w-2)
    .attr('height', h-2)
    .style('fill', 'none')
    .style('stroke-width', 0.5)
    .style('stroke', (d) => {
      if (d.t !== 0) {
        return scale(d.t);
      }
      return 'none';
    });

  let summary = d3.select('#summary');
  summary.selectAll('*').remove();
  let terrainSummary = _.chain(data).flatten().groupBy( d => d.t).value();
  let keys = Object.keys(terrainSummary);
  keys.forEach( key => {
    summary.append('div').text(key + ' ' + terrainSummary[key].length);
  });
}


canvas.on('mouseleave', function(d) {
  canvas.select('.brush').remove();
});


canvas.on('click', function(d) {
  let p = d3.mouse(this);
  let x = parseInt(p[0]/w, 10);
  let y = parseInt(p[1]/h, 10);
  apply(x, y);
  update();
});

canvas.on('mouseover', function(d) {
  let p = d3.mouse(this);
  let x = parseInt(p[0]/w, 10);
  let y = parseInt(p[1]/h, 10);

  canvas.select('.brush').remove();
  canvas.append('rect')
    .classed('brush', true)
    .attr('x', w*x - brush*w)
    .attr('y', h*y - brush*w)
    .attr('width', w + 2*brush*w)
    .attr('height', h + 2*brush*w)
    .style('pointer-events', 'none')
    .style('fill', '#FFF')
    .style('fill-opacity', 0.5)
    .style('stroke', '#555');

  if (d3.event.buttons > 0) {
    apply(x, y);
    update();
  }
});


function clearData() {
  canvas.selectAll('.cell')
    .each((d) => {
      d.h = 0;
      d.t=0;
    });
  update();
}

function serialize() {
}

function importPopup() {
  d3.select('.overlay').style('display', 'block');
}

d3.select('.overlay').on('click', function() {
  d3.select(this).style('display', 'none');
});

d3.select('.popup').on('click', function() {
  d3.event.stopPropagation();
});
d3.select('.overlay').style('display', 'none');



</script>
</html>
